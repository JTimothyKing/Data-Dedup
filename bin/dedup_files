#!/usr/bin/env perl
use 5.016;
use strict;
use warnings;

use Benchmark ':hireswallclock';
use Dedup::Files;

my $proc_processtable_available;
BEGIN {
    $proc_processtable_available = eval 'use Proc::ProcessTable; 1';
}
my $rss_scale = $^O =~ m/^darwin|sunos$/ ? 1024 : 1;


my $dir = $ARGV[0];
my $verbose = 1;


my @memory_usage;

sub record_memory_usage {
    return unless $proc_processtable_available;

    my ($name, $data) = @_;
    state $process_table_reader = new Proc::ProcessTable( enable_ttys => 0 );
    my $process_table = $process_table_reader->table;
    my ($process_data) = grep { $_->pid == $$ } @$process_table;

    warn("cannot find process entry for my PID: $$\n"), return
        unless $process_data;

    my $memory_record = {
        name => $name,
        data => $data,
        rss => $process_data->rss * $rss_scale,
    };
    push @memory_usage, $memory_record;
    return $memory_record;
}

my $dedup = Dedup::Files->new(
    dir => $dir,
);

my $mark_start = Benchmark->new;
record_memory_usage('start');


{
    my $kibi = 1024;
    my $mebi = $kibi * 1024;
    my $gibi = $mebi * 1024;
    my $tebi = $gibi * 1024;

    my %prefix_map = (
        $kibi => 'Ki',
        $mebi => 'Mi',
        $gibi => 'Gi',
        $tebi => 'Ti',
    );

    my @prefix_scales = ( $tebi, $gibi, $mebi, $kibi ); # from biggest to smallest

    sub human_readable_bytes {
        my ($bytes) = @_;

        for my $scale (@prefix_scales) {
            if (abs($bytes) > $scale) {
                return sprintf('%.1f', $bytes/$scale) . ' ' . $prefix_map{$scale} . 'B';
            }
        }
        return $bytes . ' B';
    }
}

sub print_progress {
    state $granularity = 1000; # files

    my $filesize = (@_ % 2) && shift // 0;
    my (%args) = @_;

    state $files_count = 0;
    state $bytes_count = 0;
    state $next_min_files_to_print = 0;

    $files_count++;
    $bytes_count += $filesize;

    if ($files_count >= $next_min_files_to_print || $args{force}) {
        my $human_readable_bytes = human_readable_bytes($bytes_count);
        print STDERR "\rscanned $files_count files, $human_readable_bytes";

        if ($proc_processtable_available) {
            my $memory_record = record_memory_usage("after $files_count files",
                { files => $files_count });
            my $RAM_bytes = $memory_record->{rss};
            my $human_readable_RAM = human_readable_bytes($RAM_bytes);
            my $human_readable_RAM_per_file = human_readable_bytes($RAM_bytes/$files_count);
            print STDERR " ($human_readable_RAM RAM, $human_readable_RAM_per_file/file)";
        }

        print STDERR (' ' x 12), ("\b" x 12);
        $next_min_files_to_print = (int($files_count / $granularity) + 1) * $granularity;
    }
}

$dedup->scan(
    ( progress => \&print_progress )x!! $verbose,
);
if ($verbose) {
    print_progress(force => 1);
    print STDERR "\n";
}


my $mark_end_scan = Benchmark->new;

my $file_list = $dedup->duplicates(
    resolve_hardlinks => sub { ( sort { $a cmp $b } @{$_[0]} )[0] },
);

# my $separator = '='x70 . "\n";
# print $separator;
# print
#     join $separator,
#     map {
#         join '', map "$_\n", @$_
#     } grep { @$_ > 1 } @$file_list;
# print $separator;

my $separator = '-'x30 . "\n";
print $separator;
print
    sort { $a cmp $b }
    map {
        (join "\t", sort { $a cmp $b } @$_) . "\n"
    } grep { @$_ > 1 } @$file_list;
print $separator;


record_memory_usage('final');

print "Scan time: ", timestr(timediff($mark_end_scan, $mark_start)), "\n";

if ($proc_processtable_available) {
    print "\nMemory usage:\n";
    for my $memory_record (@memory_usage) {
        my ($name, $data, $rss) = @$memory_record{qw(name data rss)};
        my $bytes_used = $rss;
        my $bytes_used_per_file = $data ? $bytes_used/$data->{files} : 0;
        print human_readable_bytes($bytes_used),
            ' ', $name,
            ( ' (', human_readable_bytes($bytes_used_per_file), '/file)' )x!! $bytes_used_per_file,
            "\n";
    }
}

__END__
